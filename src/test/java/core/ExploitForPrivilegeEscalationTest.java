package core;

import environment.NetworkNode;
import environment.NetworkWorld;
import environment.Vulnerability;
import knowledge.SoftwareKnowledge;
import knowledge.impl.SoftwareKnowledgeImpl;
import org.junit.BeforeClass;
import org.junit.Test;
import run.Simulation;

import java.util.HashSet;
import java.util.Set;

import static org.junit.Assert.*;

public class ExploitForPrivilegeEscalationTest {
    static NetworkWorld networkWorld = Simulation.getSimWorld();
    static State stateWithExploit = core.State.getStartState();
    static State withOutExploit = core.State.getStartState();
    static State withOutUserAccessButExploit = core.State.getStartState();
    static NetworkNode.TYPE target = NetworkNode.TYPE.WEBSERVER;
    static NetworkNode.TYPE currentActor = NetworkNode.TYPE.ADVERSARY;

    @BeforeClass
    public static void setUp(){
        Simulation.setupWorld(true);
        NetworkNode actualTarget = Simulation.getNodeByType(target);

        stateWithExploit.addNodeKnowledge(target);
        stateWithExploit.addNodePubIp(target, actualTarget.getPub_ip());
        stateWithExploit.addNodeHostname(target, actualTarget.getHostname());
        SoftwareKnowledge softwareKnowledge = new SoftwareKnowledgeImpl("Php",true);
        softwareKnowledge.getVulnerabilities().add(new Vulnerability("CVE-2016-1247", Vulnerability.TYPE.PRIVILEGE_ESCALATION, false));
        stateWithExploit.getSoftwareKnowledgeMap().put(target,new HashSet<SoftwareKnowledge>());
        stateWithExploit.getSoftwareKnowledgeMap().get(target).add(softwareKnowledge);
        stateWithExploit.getNodeKnowledgeMap().get(target).addAccessLevel(NetworkNode.ACCESS_LEVEL.USER);

        withOutExploit.addNodeKnowledge(target);
        withOutExploit.addNodePubIp(target, actualTarget.getPub_ip());
        withOutExploit.addNodeHostname(target, actualTarget.getHostname());
        withOutExploit.getSoftwareKnowledgeMap().put(target,new HashSet<SoftwareKnowledge>());
        withOutExploit.getNodeKnowledgeMap().get(target).addAccessLevel(NetworkNode.ACCESS_LEVEL.USER);

        withOutUserAccessButExploit.addNodeKnowledge(target);
        withOutUserAccessButExploit.addNodePubIp(target, actualTarget.getPub_ip());
        withOutUserAccessButExploit.addNodeHostname(target, actualTarget.getHostname());
        withOutUserAccessButExploit.getSoftwareKnowledgeMap().put(target,new HashSet<SoftwareKnowledge>());
        withOutUserAccessButExploit.getSoftwareKnowledgeMap().get(target).add(softwareKnowledge);
    }

    @Test
    public void testPostOfExploit(){
        assertFalse(stateWithExploit.getNodeKnowledgeMap().get(target).hasAccessLevelRoot());
        State newState = AdversaryAction.EXPLOIT_FOR_PRIVILEGE_ESCALATION.executePostConditionOnTarget(target,stateWithExploit,currentActor);
        assertTrue(newState.getNodeKnowledgeMap().get(target).hasAccessLevelRoot());
    }

    @Test
    public void testSetOfAttackableNodes(){

        Set<NetworkNode.TYPE> attackableNodes = AdversaryAction.EXPLOIT_FOR_PRIVILEGE_ESCALATION.getTargetsWhichFulfillPrecondition(withOutExploit,currentActor);
        assertFalse(attackableNodes.contains(target));

        attackableNodes = AdversaryAction.EXPLOIT_FOR_PRIVILEGE_ESCALATION.getTargetsWhichFulfillPrecondition(withOutUserAccessButExploit,currentActor);
        assertFalse(attackableNodes.contains(target));

        attackableNodes = AdversaryAction.EXPLOIT_FOR_PRIVILEGE_ESCALATION.getTargetsWhichFulfillPrecondition(stateWithExploit,currentActor);
        assertTrue(attackableNodes.contains(target));
        assertEquals(1, attackableNodes.size());
    }
}
